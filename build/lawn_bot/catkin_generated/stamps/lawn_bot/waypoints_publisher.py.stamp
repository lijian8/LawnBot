#!/usr/bin/env python

import rospy

from geometry_msgs.msg import PoseArray, Pose, Quaternion
from std_msgs.msg import Empty
from math import atan2, radians
from tf.transformations import quaternion_from_euler

class WayPointsPublisher:
    def __init__(self):
        rospy.init_node("waypoints_publisher")
        self.nodename = rospy.get_name()
        rospy.loginfo("-I- %s started" % self.nodename)

        rospy.loginfo("Prepare waypoints generated by coverage planner to go into move_base")

        # subscriptions
        rospy.Subscriber("waypoint_list", PoseArray, self.waypointsCallbak)

        # Publishing
        self.waypointsPub = rospy.Publisher("waypoints", PoseArray, queue_size=10)

        rospy.spin()

    def waypointsCallbak(self, msg):

        poseArray=PoseArray()
        poseArray.header.frame_id="map"
        poseArray.header.stamp = rospy.Time.now()

        for i in range(len(msg.poses)):
            pose = Pose()
            if i != len(msg.poses)-1:
                pose.position.x = msg.poses[i].position.x
                pose.position.y = msg.poses[i].position.y
                currentx = pose.position.x
                currenty = pose.position.y
                nextx = msg.poses[i+1].position.x
                nexty = msg.poses[i+1].position.y
                deltay= nexty-currenty
                deltax= nextx-currentx
                yaw = radians(atan2(deltay,deltax))
                q = quaternion_from_euler(0.0, 0.0, yaw)
                pose.orientation = Quaternion(*q)
            else:
                pose.position.x = msg.poses[i].position.x
                pose.position.y = msg.poses[i].position.y
                q = quaternion_from_euler(0.0, 0.0, 0.0)
                pose.orientation = Quaternion(*q)
            
            rospy.loginfo("added pose")
            poseArray.poses.append(pose)
        rospy.loginfo("publishing pose array")
        self.waypointsPub.publish(poseArray)
        


if __name__ == '__main__':
    """ main """
    try:
        WayPointsPublisher()
    except rospy.ROSInterruptException:
        pass